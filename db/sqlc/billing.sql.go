// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: billing.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAgentPayout = `-- name: CreateAgentPayout :one
INSERT INTO agent_payouts (agent_id, period_start, period_end, total_jobs, gross_amount, platform_commission, tds_deducted, net_amount)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, agent_id, period_start, period_end, total_jobs, gross_amount, platform_commission, tds_deducted, net_amount, status, razorpay_payout_id, failure_reason, created_at
`

type CreateAgentPayoutParams struct {
	AgentID            uuid.UUID      `json:"agent_id"`
	PeriodStart        pgtype.Date    `json:"period_start"`
	PeriodEnd          pgtype.Date    `json:"period_end"`
	TotalJobs          *int32         `json:"total_jobs"`
	GrossAmount        pgtype.Numeric `json:"gross_amount"`
	PlatformCommission pgtype.Numeric `json:"platform_commission"`
	TdsDeducted        pgtype.Numeric `json:"tds_deducted"`
	NetAmount          pgtype.Numeric `json:"net_amount"`
}

func (q *Queries) CreateAgentPayout(ctx context.Context, arg CreateAgentPayoutParams) (AgentPayout, error) {
	row := q.db.QueryRow(ctx, createAgentPayout,
		arg.AgentID,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.TotalJobs,
		arg.GrossAmount,
		arg.PlatformCommission,
		arg.TdsDeducted,
		arg.NetAmount,
	)
	var i AgentPayout
	err := row.Scan(
		&i.ID,
		&i.AgentID,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.TotalJobs,
		&i.GrossAmount,
		&i.PlatformCommission,
		&i.TdsDeducted,
		&i.NetAmount,
		&i.Status,
		&i.RazorpayPayoutID,
		&i.FailureReason,
		&i.CreatedAt,
	)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (user_id, parcel_id, plan, amount_per_cycle, current_period_start, current_period_end)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, parcel_id, plan, status, amount_per_cycle, razorpay_subscription_id, current_period_start, current_period_end, visits_used_this_period, on_demand_visits_remaining, created_at, updated_at
`

type CreateSubscriptionParams struct {
	UserID             uuid.UUID          `json:"user_id"`
	ParcelID           uuid.UUID          `json:"parcel_id"`
	Plan               string             `json:"plan"`
	AmountPerCycle     pgtype.Numeric     `json:"amount_per_cycle"`
	CurrentPeriodStart pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Timestamptz `json:"current_period_end"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRow(ctx, createSubscription,
		arg.UserID,
		arg.ParcelID,
		arg.Plan,
		arg.AmountPerCycle,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ParcelID,
		&i.Plan,
		&i.Status,
		&i.AmountPerCycle,
		&i.RazorpaySubscriptionID,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.VisitsUsedThisPeriod,
		&i.OnDemandVisitsRemaining,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (user_id, subscription_id, type, amount, status, razorpay_payment_id, razorpay_order_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, subscription_id, type, amount, status, razorpay_payment_id, razorpay_order_id, created_at
`

type CreateTransactionParams struct {
	UserID            uuid.UUID      `json:"user_id"`
	SubscriptionID    pgtype.UUID    `json:"subscription_id"`
	Type              string         `json:"type"`
	Amount            pgtype.Numeric `json:"amount"`
	Status            *string        `json:"status"`
	RazorpayPaymentID *string        `json:"razorpay_payment_id"`
	RazorpayOrderID   *string        `json:"razorpay_order_id"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.UserID,
		arg.SubscriptionID,
		arg.Type,
		arg.Amount,
		arg.Status,
		arg.RazorpayPaymentID,
		arg.RazorpayOrderID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubscriptionID,
		&i.Type,
		&i.Amount,
		&i.Status,
		&i.RazorpayPaymentID,
		&i.RazorpayOrderID,
		&i.CreatedAt,
	)
	return i, err
}

const getActiveSubscription = `-- name: GetActiveSubscription :one
SELECT id, user_id, parcel_id, plan, status, amount_per_cycle, razorpay_subscription_id, current_period_start, current_period_end, visits_used_this_period, on_demand_visits_remaining, created_at, updated_at FROM subscriptions WHERE parcel_id = $1 AND status = 'active' LIMIT 1
`

func (q *Queries) GetActiveSubscription(ctx context.Context, parcelID uuid.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, getActiveSubscription, parcelID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ParcelID,
		&i.Plan,
		&i.Status,
		&i.AmountPerCycle,
		&i.RazorpaySubscriptionID,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.VisitsUsedThisPeriod,
		&i.OnDemandVisitsRemaining,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, user_id, parcel_id, plan, status, amount_per_cycle, razorpay_subscription_id, current_period_start, current_period_end, visits_used_this_period, on_demand_visits_remaining, created_at, updated_at FROM subscriptions WHERE id = $1
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ParcelID,
		&i.Plan,
		&i.Status,
		&i.AmountPerCycle,
		&i.RazorpaySubscriptionID,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.VisitsUsedThisPeriod,
		&i.OnDemandVisitsRemaining,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, user_id, subscription_id, type, amount, status, razorpay_payment_id, razorpay_order_id, created_at FROM transactions WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SubscriptionID,
		&i.Type,
		&i.Amount,
		&i.Status,
		&i.RazorpayPaymentID,
		&i.RazorpayOrderID,
		&i.CreatedAt,
	)
	return i, err
}

const listPayoutsByAgent = `-- name: ListPayoutsByAgent :many
SELECT id, agent_id, period_start, period_end, total_jobs, gross_amount, platform_commission, tds_deducted, net_amount, status, razorpay_payout_id, failure_reason, created_at FROM agent_payouts WHERE agent_id = $1 ORDER BY period_end DESC LIMIT $2 OFFSET $3
`

type ListPayoutsByAgentParams struct {
	AgentID uuid.UUID `json:"agent_id"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListPayoutsByAgent(ctx context.Context, arg ListPayoutsByAgentParams) ([]AgentPayout, error) {
	rows, err := q.db.Query(ctx, listPayoutsByAgent, arg.AgentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AgentPayout{}
	for rows.Next() {
		var i AgentPayout
		if err := rows.Scan(
			&i.ID,
			&i.AgentID,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.TotalJobs,
			&i.GrossAmount,
			&i.PlatformCommission,
			&i.TdsDeducted,
			&i.NetAmount,
			&i.Status,
			&i.RazorpayPayoutID,
			&i.FailureReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByUser = `-- name: ListTransactionsByUser :many
SELECT id, user_id, subscription_id, type, amount, status, razorpay_payment_id, razorpay_order_id, created_at FROM transactions WHERE user_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListTransactionsByUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListTransactionsByUser(ctx context.Context, arg ListTransactionsByUserParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SubscriptionID,
			&i.Type,
			&i.Amount,
			&i.Status,
			&i.RazorpayPaymentID,
			&i.RazorpayOrderID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :exec
UPDATE subscriptions SET status = $2, updated_at = NOW() WHERE id = $1
`

type UpdateSubscriptionStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status *string   `json:"status"`
}

func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, arg UpdateSubscriptionStatusParams) error {
	_, err := q.db.Exec(ctx, updateSubscriptionStatus, arg.ID, arg.Status)
	return err
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :exec
UPDATE transactions SET status = $2 WHERE id = $1
`

type UpdateTransactionStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status *string   `json:"status"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) error {
	_, err := q.db.Exec(ctx, updateTransactionStatus, arg.ID, arg.Status)
	return err
}
