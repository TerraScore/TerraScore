// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: parcels.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const countParcelsByUser = `-- name: CountParcelsByUser :one
SELECT count(*) FROM parcels WHERE user_id = $1 AND status = 'active'
`

func (q *Queries) CountParcelsByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countParcelsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createParcel = `-- name: CreateParcel :one
INSERT INTO parcels (
    user_id, label, survey_number, village, taluk, district, state, state_code, pin_code,
    boundary, land_type, registered_area_sqm, title_deed_s3_key
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, ST_GeomFromGeoJSON($10), $11, $12, $13)
RETURNING id, user_id, label, survey_number, village, taluk, district, state, state_code, pin_code, boundary, centroid, area_sqm, land_type, registered_area_sqm, title_deed_s3_key, status, monitoring_since, created_at, updated_at
`

type CreateParcelParams struct {
	UserID            uuid.UUID   `json:"user_id"`
	Label             *string     `json:"label"`
	SurveyNumber      *string     `json:"survey_number"`
	Village           *string     `json:"village"`
	Taluk             *string     `json:"taluk"`
	District          string      `json:"district"`
	State             string      `json:"state"`
	StateCode         string      `json:"state_code"`
	PinCode           *string     `json:"pin_code"`
	StGeomfromgeojson interface{} `json:"st_geomfromgeojson"`
	LandType          *string     `json:"land_type"`
	RegisteredAreaSqm *float32    `json:"registered_area_sqm"`
	TitleDeedS3Key    *string     `json:"title_deed_s3_key"`
}

func (q *Queries) CreateParcel(ctx context.Context, arg CreateParcelParams) (Parcel, error) {
	row := q.db.QueryRow(ctx, createParcel,
		arg.UserID,
		arg.Label,
		arg.SurveyNumber,
		arg.Village,
		arg.Taluk,
		arg.District,
		arg.State,
		arg.StateCode,
		arg.PinCode,
		arg.StGeomfromgeojson,
		arg.LandType,
		arg.RegisteredAreaSqm,
		arg.TitleDeedS3Key,
	)
	var i Parcel
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Label,
		&i.SurveyNumber,
		&i.Village,
		&i.Taluk,
		&i.District,
		&i.State,
		&i.StateCode,
		&i.PinCode,
		&i.Boundary,
		&i.Centroid,
		&i.AreaSqm,
		&i.LandType,
		&i.RegisteredAreaSqm,
		&i.TitleDeedS3Key,
		&i.Status,
		&i.MonitoringSince,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteParcel = `-- name: DeleteParcel :exec
UPDATE parcels SET status = 'deleted', updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteParcel(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteParcel, id)
	return err
}

const findParcelsNeedingSurvey = `-- name: FindParcelsNeedingSurvey :many
SELECT p.id, p.user_id, p.label, p.survey_number, p.village, p.taluk, p.district, p.state, p.state_code, p.pin_code, p.boundary, p.centroid, p.area_sqm, p.land_type, p.registered_area_sqm, p.title_deed_s3_key, p.status, p.monitoring_since, p.created_at, p.updated_at FROM parcels p
LEFT JOIN survey_jobs sj ON sj.parcel_id = p.id AND sj.status NOT IN ('completed', 'cancelled')
WHERE p.status = 'active' AND sj.id IS NULL
ORDER BY p.monitoring_since ASC
LIMIT $1
`

func (q *Queries) FindParcelsNeedingSurvey(ctx context.Context, limit int32) ([]Parcel, error) {
	rows, err := q.db.Query(ctx, findParcelsNeedingSurvey, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Parcel{}
	for rows.Next() {
		var i Parcel
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Label,
			&i.SurveyNumber,
			&i.Village,
			&i.Taluk,
			&i.District,
			&i.State,
			&i.StateCode,
			&i.PinCode,
			&i.Boundary,
			&i.Centroid,
			&i.AreaSqm,
			&i.LandType,
			&i.RegisteredAreaSqm,
			&i.TitleDeedS3Key,
			&i.Status,
			&i.MonitoringSince,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParcelByID = `-- name: GetParcelByID :one
SELECT id, user_id, label, survey_number, village, taluk, district, state, state_code, pin_code, boundary, centroid, area_sqm, land_type, registered_area_sqm, title_deed_s3_key, status, monitoring_since, created_at, updated_at FROM parcels WHERE id = $1
`

func (q *Queries) GetParcelByID(ctx context.Context, id uuid.UUID) (Parcel, error) {
	row := q.db.QueryRow(ctx, getParcelByID, id)
	var i Parcel
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Label,
		&i.SurveyNumber,
		&i.Village,
		&i.Taluk,
		&i.District,
		&i.State,
		&i.StateCode,
		&i.PinCode,
		&i.Boundary,
		&i.Centroid,
		&i.AreaSqm,
		&i.LandType,
		&i.RegisteredAreaSqm,
		&i.TitleDeedS3Key,
		&i.Status,
		&i.MonitoringSince,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listParcelsByUser = `-- name: ListParcelsByUser :many
SELECT id, user_id, label, survey_number, village, taluk, district, state, state_code, pin_code, boundary, centroid, area_sqm, land_type, registered_area_sqm, title_deed_s3_key, status, monitoring_since, created_at, updated_at FROM parcels
WHERE user_id = $1 AND status = 'active'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListParcelsByUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListParcelsByUser(ctx context.Context, arg ListParcelsByUserParams) ([]Parcel, error) {
	rows, err := q.db.Query(ctx, listParcelsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Parcel{}
	for rows.Next() {
		var i Parcel
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Label,
			&i.SurveyNumber,
			&i.Village,
			&i.Taluk,
			&i.District,
			&i.State,
			&i.StateCode,
			&i.PinCode,
			&i.Boundary,
			&i.Centroid,
			&i.AreaSqm,
			&i.LandType,
			&i.RegisteredAreaSqm,
			&i.TitleDeedS3Key,
			&i.Status,
			&i.MonitoringSince,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateParcelStatus = `-- name: UpdateParcelStatus :exec
UPDATE parcels SET status = $2, updated_at = NOW() WHERE id = $1
`

type UpdateParcelStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status *string   `json:"status"`
}

func (q *Queries) UpdateParcelStatus(ctx context.Context, arg UpdateParcelStatusParams) error {
	_, err := q.db.Exec(ctx, updateParcelStatus, arg.ID, arg.Status)
	return err
}
