// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package sqlc

import (
	"context"
	"encoding/json"
)

const claimTask = `-- name: ClaimTask :one
UPDATE task_queue
SET status = 'processing', started_at = NOW(), attempts = attempts + 1
WHERE id = (
    SELECT id FROM task_queue
    WHERE status = 'pending' AND scheduled_at <= NOW()
    ORDER BY priority DESC, scheduled_at ASC
    LIMIT 1
    FOR UPDATE SKIP LOCKED
)
RETURNING id, task_type, payload, status, priority, attempts, max_attempts, last_error, error_message, scheduled_at, started_at, completed_at, created_at
`

func (q *Queries) ClaimTask(ctx context.Context) (TaskQueue, error) {
	row := q.db.QueryRow(ctx, claimTask)
	var i TaskQueue
	err := row.Scan(
		&i.ID,
		&i.TaskType,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.ErrorMessage,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const completeTask = `-- name: CompleteTask :exec
UPDATE task_queue SET status = 'completed', completed_at = NOW() WHERE id = $1
`

func (q *Queries) CompleteTask(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, completeTask, id)
	return err
}

const countPendingTasks = `-- name: CountPendingTasks :one
SELECT count(*) FROM task_queue WHERE status = 'pending'
`

func (q *Queries) CountPendingTasks(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingTasks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const enqueueTask = `-- name: EnqueueTask :one
INSERT INTO task_queue (task_type, payload, priority, scheduled_at)
VALUES ($1, $2, $3, COALESCE($4, NOW()))
RETURNING id, task_type, payload, status, priority, attempts, max_attempts, last_error, error_message, scheduled_at, started_at, completed_at, created_at
`

type EnqueueTaskParams struct {
	TaskType    string          `json:"task_type"`
	Payload     json.RawMessage `json:"payload"`
	Priority    *int32          `json:"priority"`
	ScheduledAt interface{}     `json:"scheduled_at"`
}

func (q *Queries) EnqueueTask(ctx context.Context, arg EnqueueTaskParams) (TaskQueue, error) {
	row := q.db.QueryRow(ctx, enqueueTask,
		arg.TaskType,
		arg.Payload,
		arg.Priority,
		arg.ScheduledAt,
	)
	var i TaskQueue
	err := row.Scan(
		&i.ID,
		&i.TaskType,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.ErrorMessage,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const failTask = `-- name: FailTask :exec
UPDATE task_queue SET
    status = CASE WHEN attempts >= max_attempts THEN 'dead' ELSE 'pending' END,
    last_error = $2,
    error_message = $2,
    completed_at = CASE WHEN attempts >= max_attempts THEN NOW() ELSE NULL END
WHERE id = $1
`

type FailTaskParams struct {
	ID        int64   `json:"id"`
	LastError *string `json:"last_error"`
}

func (q *Queries) FailTask(ctx context.Context, arg FailTaskParams) error {
	_, err := q.db.Exec(ctx, failTask, arg.ID, arg.LastError)
	return err
}
