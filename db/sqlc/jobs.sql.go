// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const assignAgent = `-- name: AssignAgent :one
UPDATE survey_jobs SET
    assigned_agent_id = $2,
    assigned_at = NOW(),
    status = 'assigned',
    cascade_round = $3,
    total_offers_sent = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, parcel_id, subscription_id, user_id, survey_type, priority, deadline, trigger, status, assigned_agent_id, assigned_at, cascade_round, total_offers_sent, agent_arrived_at, survey_started_at, survey_submitted_at, completed_at, arrival_location, arrival_distance_m, base_payout, distance_bonus, urgency_bonus, total_payout, payout_status, landowner_rating, qa_score, qa_status, qa_notes, created_at, updated_at
`

type AssignAgentParams struct {
	ID              uuid.UUID   `json:"id"`
	AssignedAgentID pgtype.UUID `json:"assigned_agent_id"`
	CascadeRound    *int32      `json:"cascade_round"`
	TotalOffersSent *int32      `json:"total_offers_sent"`
}

func (q *Queries) AssignAgent(ctx context.Context, arg AssignAgentParams) (SurveyJob, error) {
	row := q.db.QueryRow(ctx, assignAgent,
		arg.ID,
		arg.AssignedAgentID,
		arg.CascadeRound,
		arg.TotalOffersSent,
	)
	var i SurveyJob
	err := row.Scan(
		&i.ID,
		&i.ParcelID,
		&i.SubscriptionID,
		&i.UserID,
		&i.SurveyType,
		&i.Priority,
		&i.Deadline,
		&i.Trigger,
		&i.Status,
		&i.AssignedAgentID,
		&i.AssignedAt,
		&i.CascadeRound,
		&i.TotalOffersSent,
		&i.AgentArrivedAt,
		&i.SurveyStartedAt,
		&i.SurveySubmittedAt,
		&i.CompletedAt,
		&i.ArrivalLocation,
		&i.ArrivalDistanceM,
		&i.BasePayout,
		&i.DistanceBonus,
		&i.UrgencyBonus,
		&i.TotalPayout,
		&i.PayoutStatus,
		&i.LandownerRating,
		&i.QaScore,
		&i.QaStatus,
		&i.QaNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const completeJob = `-- name: CompleteJob :exec
UPDATE survey_jobs SET
    completed_at = NOW(),
    status = 'completed',
    qa_status = 'pending',
    total_payout = base_payout + distance_bonus + urgency_bonus,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) CompleteJob(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, completeJob, id)
	return err
}

const countActiveJobsByAgent = `-- name: CountActiveJobsByAgent :one
SELECT count(*) FROM survey_jobs
WHERE assigned_agent_id = $1
    AND status IN ('assigned', 'agent_on_site', 'survey_in_progress')
`

func (q *Queries) CountActiveJobsByAgent(ctx context.Context, assignedAgentID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveJobsByAgent, assignedAgentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createJobOffer = `-- name: CreateJobOffer :one
INSERT INTO job_offers (job_id, agent_id, cascade_round, offer_rank, distance_km, match_score, expires_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, job_id, agent_id, cascade_round, offer_rank, distance_km, match_score, status, sent_at, responded_at, expires_at, decline_reason
`

type CreateJobOfferParams struct {
	JobID        uuid.UUID      `json:"job_id"`
	AgentID      uuid.UUID      `json:"agent_id"`
	CascadeRound int32          `json:"cascade_round"`
	OfferRank    int32          `json:"offer_rank"`
	DistanceKm   *float32       `json:"distance_km"`
	MatchScore   pgtype.Numeric `json:"match_score"`
	ExpiresAt    time.Time      `json:"expires_at"`
}

func (q *Queries) CreateJobOffer(ctx context.Context, arg CreateJobOfferParams) (JobOffer, error) {
	row := q.db.QueryRow(ctx, createJobOffer,
		arg.JobID,
		arg.AgentID,
		arg.CascadeRound,
		arg.OfferRank,
		arg.DistanceKm,
		arg.MatchScore,
		arg.ExpiresAt,
	)
	var i JobOffer
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.AgentID,
		&i.CascadeRound,
		&i.OfferRank,
		&i.DistanceKm,
		&i.MatchScore,
		&i.Status,
		&i.SentAt,
		&i.RespondedAt,
		&i.ExpiresAt,
		&i.DeclineReason,
	)
	return i, err
}

const createSurveyJob = `-- name: CreateSurveyJob :one
INSERT INTO survey_jobs (
    parcel_id, subscription_id, user_id, survey_type, priority, deadline, trigger, base_payout
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, parcel_id, subscription_id, user_id, survey_type, priority, deadline, trigger, status, assigned_agent_id, assigned_at, cascade_round, total_offers_sent, agent_arrived_at, survey_started_at, survey_submitted_at, completed_at, arrival_location, arrival_distance_m, base_payout, distance_bonus, urgency_bonus, total_payout, payout_status, landowner_rating, qa_score, qa_status, qa_notes, created_at, updated_at
`

type CreateSurveyJobParams struct {
	ParcelID       uuid.UUID      `json:"parcel_id"`
	SubscriptionID pgtype.UUID    `json:"subscription_id"`
	UserID         uuid.UUID      `json:"user_id"`
	SurveyType     string         `json:"survey_type"`
	Priority       *string        `json:"priority"`
	Deadline       time.Time      `json:"deadline"`
	Trigger        *string        `json:"trigger"`
	BasePayout     pgtype.Numeric `json:"base_payout"`
}

func (q *Queries) CreateSurveyJob(ctx context.Context, arg CreateSurveyJobParams) (SurveyJob, error) {
	row := q.db.QueryRow(ctx, createSurveyJob,
		arg.ParcelID,
		arg.SubscriptionID,
		arg.UserID,
		arg.SurveyType,
		arg.Priority,
		arg.Deadline,
		arg.Trigger,
		arg.BasePayout,
	)
	var i SurveyJob
	err := row.Scan(
		&i.ID,
		&i.ParcelID,
		&i.SubscriptionID,
		&i.UserID,
		&i.SurveyType,
		&i.Priority,
		&i.Deadline,
		&i.Trigger,
		&i.Status,
		&i.AssignedAgentID,
		&i.AssignedAt,
		&i.CascadeRound,
		&i.TotalOffersSent,
		&i.AgentArrivedAt,
		&i.SurveyStartedAt,
		&i.SurveySubmittedAt,
		&i.CompletedAt,
		&i.ArrivalLocation,
		&i.ArrivalDistanceM,
		&i.BasePayout,
		&i.DistanceBonus,
		&i.UrgencyBonus,
		&i.TotalPayout,
		&i.PayoutStatus,
		&i.LandownerRating,
		&i.QaScore,
		&i.QaStatus,
		&i.QaNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const expireOffers = `-- name: ExpireOffers :exec
UPDATE job_offers SET status = 'expired' WHERE expires_at < NOW() AND status = 'sent'
`

func (q *Queries) ExpireOffers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, expireOffers)
	return err
}

const getOfferByJobAndAgent = `-- name: GetOfferByJobAndAgent :one
SELECT id, job_id, agent_id, cascade_round, offer_rank, distance_km, match_score, status, sent_at, responded_at, expires_at, decline_reason FROM job_offers WHERE job_id = $1 AND agent_id = $2 AND status = 'sent'
`

type GetOfferByJobAndAgentParams struct {
	JobID   uuid.UUID `json:"job_id"`
	AgentID uuid.UUID `json:"agent_id"`
}

func (q *Queries) GetOfferByJobAndAgent(ctx context.Context, arg GetOfferByJobAndAgentParams) (JobOffer, error) {
	row := q.db.QueryRow(ctx, getOfferByJobAndAgent, arg.JobID, arg.AgentID)
	var i JobOffer
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.AgentID,
		&i.CascadeRound,
		&i.OfferRank,
		&i.DistanceKm,
		&i.MatchScore,
		&i.Status,
		&i.SentAt,
		&i.RespondedAt,
		&i.ExpiresAt,
		&i.DeclineReason,
	)
	return i, err
}

const getPendingOfferByID = `-- name: GetPendingOfferByID :one
SELECT id, job_id, agent_id, cascade_round, offer_rank, distance_km, match_score, status, sent_at, responded_at, expires_at, decline_reason FROM job_offers WHERE id = $1 AND status = 'sent'
`

func (q *Queries) GetPendingOfferByID(ctx context.Context, id uuid.UUID) (JobOffer, error) {
	row := q.db.QueryRow(ctx, getPendingOfferByID, id)
	var i JobOffer
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.AgentID,
		&i.CascadeRound,
		&i.OfferRank,
		&i.DistanceKm,
		&i.MatchScore,
		&i.Status,
		&i.SentAt,
		&i.RespondedAt,
		&i.ExpiresAt,
		&i.DeclineReason,
	)
	return i, err
}

const getSurveyJobByID = `-- name: GetSurveyJobByID :one
SELECT id, parcel_id, subscription_id, user_id, survey_type, priority, deadline, trigger, status, assigned_agent_id, assigned_at, cascade_round, total_offers_sent, agent_arrived_at, survey_started_at, survey_submitted_at, completed_at, arrival_location, arrival_distance_m, base_payout, distance_bonus, urgency_bonus, total_payout, payout_status, landowner_rating, qa_score, qa_status, qa_notes, created_at, updated_at FROM survey_jobs WHERE id = $1
`

func (q *Queries) GetSurveyJobByID(ctx context.Context, id uuid.UUID) (SurveyJob, error) {
	row := q.db.QueryRow(ctx, getSurveyJobByID, id)
	var i SurveyJob
	err := row.Scan(
		&i.ID,
		&i.ParcelID,
		&i.SubscriptionID,
		&i.UserID,
		&i.SurveyType,
		&i.Priority,
		&i.Deadline,
		&i.Trigger,
		&i.Status,
		&i.AssignedAgentID,
		&i.AssignedAt,
		&i.CascadeRound,
		&i.TotalOffersSent,
		&i.AgentArrivedAt,
		&i.SurveyStartedAt,
		&i.SurveySubmittedAt,
		&i.CompletedAt,
		&i.ArrivalLocation,
		&i.ArrivalDistanceM,
		&i.BasePayout,
		&i.DistanceBonus,
		&i.UrgencyBonus,
		&i.TotalPayout,
		&i.PayoutStatus,
		&i.LandownerRating,
		&i.QaScore,
		&i.QaStatus,
		&i.QaNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listJobsByAgent = `-- name: ListJobsByAgent :many
SELECT id, parcel_id, subscription_id, user_id, survey_type, priority, deadline, trigger, status, assigned_agent_id, assigned_at, cascade_round, total_offers_sent, agent_arrived_at, survey_started_at, survey_submitted_at, completed_at, arrival_location, arrival_distance_m, base_payout, distance_bonus, urgency_bonus, total_payout, payout_status, landowner_rating, qa_score, qa_status, qa_notes, created_at, updated_at FROM survey_jobs
WHERE assigned_agent_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListJobsByAgentParams struct {
	AssignedAgentID pgtype.UUID `json:"assigned_agent_id"`
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
}

func (q *Queries) ListJobsByAgent(ctx context.Context, arg ListJobsByAgentParams) ([]SurveyJob, error) {
	rows, err := q.db.Query(ctx, listJobsByAgent, arg.AssignedAgentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyJob{}
	for rows.Next() {
		var i SurveyJob
		if err := rows.Scan(
			&i.ID,
			&i.ParcelID,
			&i.SubscriptionID,
			&i.UserID,
			&i.SurveyType,
			&i.Priority,
			&i.Deadline,
			&i.Trigger,
			&i.Status,
			&i.AssignedAgentID,
			&i.AssignedAt,
			&i.CascadeRound,
			&i.TotalOffersSent,
			&i.AgentArrivedAt,
			&i.SurveyStartedAt,
			&i.SurveySubmittedAt,
			&i.CompletedAt,
			&i.ArrivalLocation,
			&i.ArrivalDistanceM,
			&i.BasePayout,
			&i.DistanceBonus,
			&i.UrgencyBonus,
			&i.TotalPayout,
			&i.PayoutStatus,
			&i.LandownerRating,
			&i.QaScore,
			&i.QaStatus,
			&i.QaNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsByParcel = `-- name: ListJobsByParcel :many
SELECT id, parcel_id, subscription_id, user_id, survey_type, priority, deadline, trigger, status, assigned_agent_id, assigned_at, cascade_round, total_offers_sent, agent_arrived_at, survey_started_at, survey_submitted_at, completed_at, arrival_location, arrival_distance_m, base_payout, distance_bonus, urgency_bonus, total_payout, payout_status, landowner_rating, qa_score, qa_status, qa_notes, created_at, updated_at FROM survey_jobs
WHERE parcel_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListJobsByParcelParams struct {
	ParcelID uuid.UUID `json:"parcel_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListJobsByParcel(ctx context.Context, arg ListJobsByParcelParams) ([]SurveyJob, error) {
	rows, err := q.db.Query(ctx, listJobsByParcel, arg.ParcelID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyJob{}
	for rows.Next() {
		var i SurveyJob
		if err := rows.Scan(
			&i.ID,
			&i.ParcelID,
			&i.SubscriptionID,
			&i.UserID,
			&i.SurveyType,
			&i.Priority,
			&i.Deadline,
			&i.Trigger,
			&i.Status,
			&i.AssignedAgentID,
			&i.AssignedAt,
			&i.CascadeRound,
			&i.TotalOffersSent,
			&i.AgentArrivedAt,
			&i.SurveyStartedAt,
			&i.SurveySubmittedAt,
			&i.CompletedAt,
			&i.ArrivalLocation,
			&i.ArrivalDistanceM,
			&i.BasePayout,
			&i.DistanceBonus,
			&i.UrgencyBonus,
			&i.TotalPayout,
			&i.PayoutStatus,
			&i.LandownerRating,
			&i.QaScore,
			&i.QaStatus,
			&i.QaNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOffersByJob = `-- name: ListOffersByJob :many
SELECT id, job_id, agent_id, cascade_round, offer_rank, distance_km, match_score, status, sent_at, responded_at, expires_at, decline_reason FROM job_offers WHERE job_id = $1 ORDER BY cascade_round, offer_rank
`

func (q *Queries) ListOffersByJob(ctx context.Context, jobID uuid.UUID) ([]JobOffer, error) {
	rows, err := q.db.Query(ctx, listOffersByJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobOffer{}
	for rows.Next() {
		var i JobOffer
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.AgentID,
			&i.CascadeRound,
			&i.OfferRank,
			&i.DistanceKm,
			&i.MatchScore,
			&i.Status,
			&i.SentAt,
			&i.RespondedAt,
			&i.ExpiresAt,
			&i.DeclineReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingJobs = `-- name: ListPendingJobs :many
SELECT id, parcel_id, subscription_id, user_id, survey_type, priority, deadline, trigger, status, assigned_agent_id, assigned_at, cascade_round, total_offers_sent, agent_arrived_at, survey_started_at, survey_submitted_at, completed_at, arrival_location, arrival_distance_m, base_payout, distance_bonus, urgency_bonus, total_payout, payout_status, landowner_rating, qa_score, qa_status, qa_notes, created_at, updated_at FROM survey_jobs
WHERE status IN ('pending_assignment', 'offered')
ORDER BY deadline ASC
LIMIT $1
`

func (q *Queries) ListPendingJobs(ctx context.Context, limit int32) ([]SurveyJob, error) {
	rows, err := q.db.Query(ctx, listPendingJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SurveyJob{}
	for rows.Next() {
		var i SurveyJob
		if err := rows.Scan(
			&i.ID,
			&i.ParcelID,
			&i.SubscriptionID,
			&i.UserID,
			&i.SurveyType,
			&i.Priority,
			&i.Deadline,
			&i.Trigger,
			&i.Status,
			&i.AssignedAgentID,
			&i.AssignedAt,
			&i.CascadeRound,
			&i.TotalOffersSent,
			&i.AgentArrivedAt,
			&i.SurveyStartedAt,
			&i.SurveySubmittedAt,
			&i.CompletedAt,
			&i.ArrivalLocation,
			&i.ArrivalDistanceM,
			&i.BasePayout,
			&i.DistanceBonus,
			&i.UrgencyBonus,
			&i.TotalPayout,
			&i.PayoutStatus,
			&i.LandownerRating,
			&i.QaScore,
			&i.QaStatus,
			&i.QaNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingOffersByAgent = `-- name: ListPendingOffersByAgent :many
SELECT id, job_id, agent_id, cascade_round, offer_rank, distance_km, match_score, status, sent_at, responded_at, expires_at, decline_reason FROM job_offers
WHERE agent_id = $1 AND status = 'sent'
ORDER BY sent_at DESC
`

func (q *Queries) ListPendingOffersByAgent(ctx context.Context, agentID uuid.UUID) ([]JobOffer, error) {
	rows, err := q.db.Query(ctx, listPendingOffersByAgent, agentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobOffer{}
	for rows.Next() {
		var i JobOffer
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.AgentID,
			&i.CascadeRound,
			&i.OfferRank,
			&i.DistanceKm,
			&i.MatchScore,
			&i.Status,
			&i.SentAt,
			&i.RespondedAt,
			&i.ExpiresAt,
			&i.DeclineReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordAgentArrival = `-- name: RecordAgentArrival :exec
UPDATE survey_jobs SET
    agent_arrived_at = NOW(),
    arrival_location = ST_SetSRID(ST_MakePoint($2, $3), 4326),
    arrival_distance_m = $4,
    status = 'agent_on_site',
    updated_at = NOW()
WHERE id = $1
`

type RecordAgentArrivalParams struct {
	ID               uuid.UUID   `json:"id"`
	StMakepoint      interface{} `json:"st_makepoint"`
	StMakepoint_2    interface{} `json:"st_makepoint_2"`
	ArrivalDistanceM *float32    `json:"arrival_distance_m"`
}

func (q *Queries) RecordAgentArrival(ctx context.Context, arg RecordAgentArrivalParams) error {
	_, err := q.db.Exec(ctx, recordAgentArrival,
		arg.ID,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.ArrivalDistanceM,
	)
	return err
}

const updateJobOfferStatus = `-- name: UpdateJobOfferStatus :exec
UPDATE job_offers SET status = $2, responded_at = NOW(), decline_reason = $3 WHERE id = $1
`

type UpdateJobOfferStatusParams struct {
	ID            uuid.UUID `json:"id"`
	Status        *string   `json:"status"`
	DeclineReason *string   `json:"decline_reason"`
}

func (q *Queries) UpdateJobOfferStatus(ctx context.Context, arg UpdateJobOfferStatusParams) error {
	_, err := q.db.Exec(ctx, updateJobOfferStatus, arg.ID, arg.Status, arg.DeclineReason)
	return err
}

const updateJobQA = `-- name: UpdateJobQA :exec
UPDATE survey_jobs SET
    qa_score = $2,
    qa_status = $3,
    qa_notes = $4,
    updated_at = NOW()
WHERE id = $1
`

type UpdateJobQAParams struct {
	ID       uuid.UUID      `json:"id"`
	QaScore  pgtype.Numeric `json:"qa_score"`
	QaStatus *string        `json:"qa_status"`
	QaNotes  *string        `json:"qa_notes"`
}

func (q *Queries) UpdateJobQA(ctx context.Context, arg UpdateJobQAParams) error {
	_, err := q.db.Exec(ctx, updateJobQA,
		arg.ID,
		arg.QaScore,
		arg.QaStatus,
		arg.QaNotes,
	)
	return err
}

const updateJobStatus = `-- name: UpdateJobStatus :one
UPDATE survey_jobs SET status = $2, updated_at = NOW() WHERE id = $1 RETURNING id, parcel_id, subscription_id, user_id, survey_type, priority, deadline, trigger, status, assigned_agent_id, assigned_at, cascade_round, total_offers_sent, agent_arrived_at, survey_started_at, survey_submitted_at, completed_at, arrival_location, arrival_distance_m, base_payout, distance_bonus, urgency_bonus, total_payout, payout_status, landowner_rating, qa_score, qa_status, qa_notes, created_at, updated_at
`

type UpdateJobStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status *string   `json:"status"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) (SurveyJob, error) {
	row := q.db.QueryRow(ctx, updateJobStatus, arg.ID, arg.Status)
	var i SurveyJob
	err := row.Scan(
		&i.ID,
		&i.ParcelID,
		&i.SubscriptionID,
		&i.UserID,
		&i.SurveyType,
		&i.Priority,
		&i.Deadline,
		&i.Trigger,
		&i.Status,
		&i.AssignedAgentID,
		&i.AssignedAt,
		&i.CascadeRound,
		&i.TotalOffersSent,
		&i.AgentArrivedAt,
		&i.SurveyStartedAt,
		&i.SurveySubmittedAt,
		&i.CompletedAt,
		&i.ArrivalLocation,
		&i.ArrivalDistanceM,
		&i.BasePayout,
		&i.DistanceBonus,
		&i.UrgencyBonus,
		&i.TotalPayout,
		&i.PayoutStatus,
		&i.LandownerRating,
		&i.QaScore,
		&i.QaStatus,
		&i.QaNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
